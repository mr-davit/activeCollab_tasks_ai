/**
 * Init command for ac-task CLI
 * 
 * Maps a repository to an ActiveCollab project and generates:
 * - .ac-task.json (project config)
 * - .ai/ACTIVE_COLLAB_PROJECT_GUIDE.md (context for LLM agents)
 * - .ai/AC_TASK_AGENT_INSTRUCTIONS.md (static user manual for agents)
 */

import { Command } from 'commander';
import { input } from '@inquirer/prompts';
import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import { OutputFormat, ProjectConfig, ACProject, ACUser, ACTaskList } from '../types';
import { loadGlobalConfig, requireGlobalConfig } from '../config/loader';
import { getProjectRoot, PROJECT_CONFIG_FILENAME } from '../config/paths';
import { fetchProject, fetchProjectUsers, fetchTaskLists } from '../api/utils';
import { getClient } from '../api/client';
import { ACTaskError, handleError } from '../utils/errorHandler';
import { output, success, info, warning } from '../utils/formatting';
import { formatDate } from '../utils/date';

/**
 * Package names for detecting local installation (scoped and unscoped)
 */
const PACKAGE_NAMES = ['@mr-davit/activecollab-task-cli', 'activecollab-task-cli'];

/**
 * Detect if the package is installed locally in the target directory
 * Returns 'npx ac-task' for local installs, 'ac-task' for global
 */
function detectCommandPrefix(targetDir: string): string {
    const packageJsonPath = path.join(targetDir, 'package.json');

    try {
        if (fs.existsSync(packageJsonPath)) {
            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
            const deps = packageJson.dependencies || {};
            const devDeps = packageJson.devDependencies || {};

            for (const pkgName of PACKAGE_NAMES) {
                if (deps[pkgName] || devDeps[pkgName]) {
                    return 'npx ac-task';
                }
            }
        }
    } catch {
        // If we can't read package.json, assume global install
    }

    return 'ac-task';
}

/**
 * Generate Agent Instructions with dynamic command prefix
 */
function generateAgentInstructions(prefix: string): string {
    return `# AC Task: Agent Instructions
> **Note:** This file is auto-generated by \`ac-task init\`. It helps AI agents (Copilot, Cursor, ChatGPT) understand how to use the CLI in this repo.

## 1. The Golden Rules
1. **Source of Truth:** ALWAYS read \`.ai/ACTIVE_COLLAB_PROJECT_GUIDE.md\` to find **User IDs** and **Task List IDs**.
2. **Output:** Always add \`--format json\` to get structured data.
3. **Safety:** Never delete without confirmation. Verify \`create\` payloads with the user.

## 2. Common Patterns
- **Dashboard:** \`${prefix} list --format json\` (defaults to my open tasks)
- **All Tasks:** \`${prefix} list --all --format json\`
- **Search:** \`${prefix} list --search "query" --format json\`
- **Details:** \`${prefix} show <task_id> --format json\`
- **Create:** \`${prefix} create "Title" --assignee <id_from_guide> --list <id_from_guide> --format json\`
- **Update:** \`${prefix} update <task_id> --name "New Title" --due YYYY-MM-DD --format json\`
- **Complete:** \`${prefix} update-status <task_id> done\`
- **Reopen:** \`${prefix} update-status <task_id> open\`
- **Comment:** \`${prefix} comment <task_id> "Comment text" --format json\`
- **Log Time:** \`${prefix} log <task_id> <hours> --summary "Work done" --job-type <id> --format json\`
- **Delete:** \`${prefix} delete <task_id> --force\` (use with caution)

## 3. Date Format
All dates use **YYYY-MM-DD** format (e.g., 2025-12-09).

## 4. Error Handling
Errors return JSON with this structure:
\`\`\`json
{
  "error": {
    "type": "ERROR_TYPE",
    "code": 400,
    "message": "Human readable message",
    "details": "Additional context"
  }
}
\`\`\`
`;
}

/**
 * Get the output format from command options
 */
function getFormat(options: { format?: string }): OutputFormat {
    return options.format === 'json' ? 'json' : 'human';
}

/**
 * Generate the project guide markdown content
 */
function generateProjectGuide(
    project: ACProject,
    users: ACUser[],
    taskLists: ACTaskList[],
    globalConfig: { cached_user_id: number; cached_user_name: string; base_url: string }
): string {
    const now = new Date();
    const generatedDate = formatDate(now);

    // Build user list
    const userLines = users
        .map(u => `- **${u.display_name || `${u.first_name} ${u.last_name}`}** (ID: ${u.id}) - ${u.email}`)
        .join('\n');

    // Build task list
    const taskListLines = taskLists
        .map(tl => `- **${tl.name}** (ID: ${tl.id})${tl.open_tasks !== undefined ? ` - ${tl.open_tasks} open tasks` : ''}`)
        .join('\n');

    // Construct browser URL (remove /api/v1 and add project path)
    const browserUrl = globalConfig.base_url
        .replace(/\/api\/v\d+\/?$/, '')
        + `/projects/${project.id}`;

    return `# ActiveCollab Project: ${project.name} (ID: ${project.id})

**URL:** ${browserUrl}

---

## Project Description

${project.body_formatted || project.body || '_No description provided._'}

---

## Users (Reference for @mentions and assignments)

${userLines || '_No users found._'}

---

## Task Lists (Categories)

${taskListLines || '_No task lists found._'}

---

## Agent Instructions

When working with this ActiveCollab project:

1. **My User ID is ${globalConfig.cached_user_id}** (${globalConfig.cached_user_name}). Default to assigning tasks to me unless specified otherwise.

2. **Use Task List IDs** from the list above when creating tasks. If unsure, use the first available list.

3. **Task References:**
   - Use \`ac-task list\` to see my open tasks (smart default)
   - Use \`ac-task list --all\` to see all tasks
   - Use \`ac-task show <task_id>\` to see task details

4. **Date Format:** All dates should be in YYYY-MM-DD format.

5. **Project ID:** ${project.id} - This is configured in \`.ac-task.json\`

---

_Generated on ${generatedDate} by ac-task CLI_
`;
}

/**
 * Save the project config file (.ac-task.json)
 */
function saveProjectConfig(projectId: number, targetDir: string): void {
    const config: ProjectConfig = {
        project_id: projectId,
        defaults: {
            lookahead_days: 7,
        },
    };

    const configPath = path.join(targetDir, PROJECT_CONFIG_FILENAME);
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');
}

/**
 * Save the project guide markdown file
 */
function saveProjectGuide(content: string, targetDir: string): void {
    const aiDir = path.join(targetDir, '.ai');

    // Ensure .ai directory exists
    if (!fs.existsSync(aiDir)) {
        fs.mkdirSync(aiDir, { recursive: true });
    }

    const guidePath = path.join(aiDir, 'ACTIVE_COLLAB_PROJECT_GUIDE.md');
    fs.writeFileSync(guidePath, content, 'utf-8');
}

/**
 * Save the agent instructions file with dynamic command prefix
 */
function saveAgentInstructions(targetDir: string): void {
    const aiDir = path.join(targetDir, '.ai');

    // Ensure .ai directory exists
    if (!fs.existsSync(aiDir)) {
        fs.mkdirSync(aiDir, { recursive: true });
    }

    // Detect local vs global install
    const prefix = detectCommandPrefix(targetDir);
    const instructions = generateAgentInstructions(prefix);

    const instructionsPath = path.join(aiDir, 'AC_TASK_AGENT_INSTRUCTIONS.md');
    fs.writeFileSync(instructionsPath, instructions, 'utf-8');
}

/**
 * init command handler
 */
async function initHandler(options: { format?: string; project?: string }): Promise<void> {
    const format = getFormat(options);

    try {
        // Require global config (auth must be done first)
        const globalConfig = requireGlobalConfig();

        // Determine target directory (cwd or existing project root)
        let targetDir = process.cwd();
        const existingRoot = getProjectRoot();
        if (existingRoot) {
            targetDir = existingRoot;
            if (format === 'human') {
                console.log(info(`Found existing project at ${existingRoot}`));
            }
        }

        // Get project ID
        let projectId: number;
        if (options.project) {
            projectId = parseInt(options.project, 10);
            if (isNaN(projectId)) {
                throw new ACTaskError(
                    'VALIDATION_ERROR',
                    'Invalid project ID',
                    1,
                    'Project ID must be a number.'
                );
            }
        } else {
            // Interactive: ask for project ID
            const projectIdStr = await input({
                message: 'Enter the ActiveCollab Project ID for this repository:',
                validate: (value) => {
                    const num = parseInt(value, 10);
                    if (isNaN(num) || num <= 0) {
                        return 'Please enter a valid positive number';
                    }
                    return true;
                },
            });
            projectId = parseInt(projectIdStr, 10);
        }

        // Fetch project data
        if (format === 'human') {
            console.log(info('Fetching project data...'));
        }

        const client = getClient();

        // Fetch all data in parallel
        let project: ACProject;
        let users: ACUser[];
        let taskLists: ACTaskList[];

        try {
            [project, users, taskLists] = await Promise.all([
                fetchProject(projectId, client),
                fetchProjectUsers(projectId, client),
                fetchTaskLists(projectId, client),
            ]);
        } catch (err) {
            // Check if it's a 404 (project not found)
            if (err instanceof ACTaskError && err.code === 404) {
                throw new ACTaskError(
                    'API_ERROR',
                    `Project ${projectId} not found`,
                    404,
                    'Please verify the project ID exists and you have access to it.'
                );
            }
            throw err;
        }

        // Generate and save files
        if (format === 'human') {
            console.log(info(`Initializing project: ${project.name}`));
        }

        // Save .ac-task.json
        saveProjectConfig(projectId, targetDir);

        // Generate and save guide
        const guideContent = generateProjectGuide(project, users, taskLists, globalConfig);
        saveProjectGuide(guideContent, targetDir);

        // Save static agent instructions
        saveAgentInstructions(targetDir);

        // Output success
        if (format === 'json') {
            output({
                success: true,
                project: {
                    id: project.id,
                    name: project.name,
                },
                files: {
                    config: path.join(targetDir, PROJECT_CONFIG_FILENAME),
                    guide: path.join(targetDir, '.ai', 'ACTIVE_COLLAB_PROJECT_GUIDE.md'),
                    instructions: path.join(targetDir, '.ai', 'AC_TASK_AGENT_INSTRUCTIONS.md'),
                },
                users: users.length,
                task_lists: taskLists.length,
            }, format);
        } else {
            console.log('');
            console.log(success(`Initialized project: ${chalk.bold(project.name)} (ID: ${project.id})`));
            console.log('');
            console.log(info('Created files:'));
            console.log(`  ${chalk.cyan(PROJECT_CONFIG_FILENAME)} - Project configuration`);
            console.log(`  ${chalk.cyan('.ai/ACTIVE_COLLAB_PROJECT_GUIDE.md')} - LLM context guide`);
            console.log(`  ${chalk.cyan('.ai/AC_TASK_AGENT_INSTRUCTIONS.md')} - Agent user manual`);
            console.log('');
            console.log(info(`Found ${users.length} users and ${taskLists.length} task lists`));
            console.log('');
            console.log(chalk.gray('Run `ac-task list` to see your open tasks.'));
        }
    } catch (err) {
        handleError(err, format);
    }
}

/**
 * Register init command with the CLI program
 */
export function registerInitCommand(program: Command): void {
    program
        .command('init')
        .description('Initialize project and generate LLM context guide')
        .option('-f, --format <format>', 'Output format (human|json)', 'human')
        .option('-p, --project <id>', 'ActiveCollab project ID')
        .action(initHandler);
}
